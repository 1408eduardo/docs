---
sidebar_position: 4
---

# Messages

<CH.Scrollycoding>

## CreateStreamMsg

_`pub name:`_ The name of the stream.  
_`pub immutable:`_ Whether the stream is immutable or not. Immutable streams cannot be changed.  
_`pub asset_info:`_ The [`AssetInfo`] that represents the token that is streamed.  
_`pub recipient_addr:`_ The recipient's wallet address.  
_`pub issuance_start_timestamp:`_ The time, in seconds, that the stream will begin.   
_`pub issuance_end_timestamp:`_ The time, in seconds, that the stream will end.  



``` rust minter.rs focus=101:115
use crate::nft::Extension;
use cosmwasm_std::{Addr, Binary, Uint128, Uint64};
use cw20::Cw20ReceiveMsg;
use cw721::Expiration;
use cw721_base::msg::{ExecuteMsg as CW721ExecuteMsg, QueryMsg as CW721QueryMsg};

use cw_asset::AssetInfo;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct InstantiateMsg {
    pub owner: Option<String>,
}

pub const NFT_INSTANTIATE_REPLY_ID: u64 = 1;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct Config {
    /// Admin of this contract
    pub owner: Addr,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum StreamStatus {
    Valid,
    Cancelled,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct StreamInfo {
    pub status: StreamStatus,
    pub immutable: bool,
    pub nft_token_id: String,
    pub token_id: Uint64,
    pub name: String,
    pub asset_info: AssetInfo,
    pub creator_addr: Addr,
    pub issuance_start_timestamp: Uint64,
    pub issuance_end_timestamp: Uint64,
    pub last_claimed_timestamp: Uint64,
    pub total_funded: Uint128,
    pub funds_remaining: Uint128,
}

impl StreamInfo {
    pub fn keys() -> Vec<String> {
        return vec![
            "status".to_string(),
            "immutable".to_string(),
            "asset_info".to_string(),
            "creator_addr".to_string(),
            "issuance_start_timestamp".to_string(),
            "issuance_last_timestamp".to_string(),
            "last_claimed_timestamp".to_string(),
            "total_funded".to_string(),
            "funds_remaining".to_string(),
        ];
    }
    pub fn values(&self) -> Vec<String> {
        let status_string = match self.status.clone() {
            StreamStatus::Valid => "valid",
            StreamStatus::Cancelled => "cancelled",
        };
        let asset_info_string = match self.asset_info.clone() {
            AssetInfo::Cw20(address) => address.to_string(),
            AssetInfo::Native(denom) => denom,
        };
        return vec![
            status_string.to_string(),
            self.immutable.to_string(),
            asset_info_string,
            self.creator_addr.to_string(),
            self.issuance_start_timestamp.to_string(),
            self.issuance_end_timestamp.to_string(),
            self.last_claimed_timestamp.to_string(),
            self.total_funded.to_string(),
            self.funds_remaining.to_string(),
        ];
    }
    pub fn display_type() -> Vec<String> {
        return vec![
            "string".to_string(),
            "string".to_string(),
            "string".to_string(),
            "string".to_string(),
            "date".to_string(),
            "date".to_string(),
            "date".to_string(),
            "number".to_string(),
            "number".to_string(),
        ];
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct CreateStreamMsg {
    /// The name of the stream
    pub name: String,
    /// Whether the stream is immutable or not
    pub immutable: bool,
    /// The [`AssetInfo`] that represents the token that is streamed
    pub asset_info: AssetInfo,
    /// The recipient's wallet address
    pub recipient_addr: String,
    /// The time, in seconds, that the stream will begin
    pub issuance_start_timestamp: Uint64,
    /// The time, in seconds, that the stream will end
    pub issuance_end_timestamp: Uint64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct FundStreamMsg {
    /// The ID of the stream to fund
    pub stream_id: Uint64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimFundsMsg {
    /// A list of IDs of streams that will be claimed from
    pub stream_ids: Vec<Uint64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimAllFundsMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ChangeStreamInfoMsg {
    /// The ID of the stream to change
    pub stream_id: Uint64,
    /// If specified, the new name of the stream
    pub name: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct CancelStreamMsg {
    /// The ID of the stream to cancel
    pub stream_id: Uint64,
    /// If specified, the address that receives the cancellation's refund
    pub recipient_addr: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Transfer NFT message
pub struct TransferNftMsg {
    pub recipient: String,
    pub token_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Send NFT message
pub struct SendNftMsg {
    pub contract: String,
    pub token_id: String,
    pub msg: Binary,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Approve token usage message
pub struct ApproveMsg {
    pub spender: String,
    pub token_id: String,
    pub expires: Option<Expiration>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Revoke Approval message
pub struct RevokeMsg {
    pub spender: String,
    pub token_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Approve all tokens message
pub struct ApproveAllMsg {
    pub operator: String,
    pub expires: Option<Expiration>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Revoke all approval message
pub struct RevokeAllMsg {
    pub operator: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    CreateStream(CreateStreamMsg),
    FundStream(FundStreamMsg),
    ClaimFunds(ClaimFundsMsg),
    ClaimAllFunds(ClaimAllFundsMsg),
    ChangeStreamInfo(ChangeStreamInfoMsg),
    CancelStream(CancelStreamMsg),
    Receive(Cw20ReceiveMsg),

    TransferNft(TransferNftMsg),
    SendNft(SendNftMsg),
    Approve(ApproveMsg),
    Revoke(RevokeMsg),
    ApproveAll(ApproveAllMsg),
    RevokeAll(RevokeAllMsg),
}

impl From<ExecuteMsg> for CW721ExecuteMsg<Extension> {
    fn from(msg: ExecuteMsg) -> CW721ExecuteMsg<Extension> {
        match msg {
            ExecuteMsg::TransferNft(msg) => CW721ExecuteMsg::TransferNft {
                recipient: msg.recipient,
                token_id: msg.token_id,
            },
            ExecuteMsg::SendNft(msg) => CW721ExecuteMsg::SendNft {
                contract: msg.contract,
                token_id: msg.token_id,
                msg: msg.msg,
            },
            ExecuteMsg::Approve(msg) => CW721ExecuteMsg::Approve {
                spender: msg.spender,
                token_id: msg.token_id,
                expires: msg.expires,
            },
            ExecuteMsg::Revoke(msg) => CW721ExecuteMsg::Revoke {
                spender: msg.spender,
                token_id: msg.token_id,
            },
            ExecuteMsg::ApproveAll(msg) => CW721ExecuteMsg::ApproveAll {
                operator: msg.operator,
                expires: msg.expires,
            },
            ExecuteMsg::RevokeAll(msg) => CW721ExecuteMsg::RevokeAll {
                operator: msg.operator,
            },
            _ => panic!("cannot covert {:?} to CW721ExecuteMsg", msg),
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct MigrateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum Cw20HookMsg {
    CreateStream(CreateStreamMsg),
    FundStream(FundStreamMsg),
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct QueryStreamsMsg {
    /// A list of stream IDs to query
    pub stream_ids: Option<Vec<Uint64>>,
    /// A creator's address. Streams created by this address will be returned.
    pub creator: Option<String>,
    /// A recipient's address. Streams that transfer to this address will be returned.
    pub recipient: Option<String>,
    /// A stream ID used for pagination of results. If specified, the page that begins after this ID will be returned.
    pub start_after: Option<Uint64>,
}

impl QueryStreamsMsg {
    pub fn is_valid(&self) -> bool {
        (self.stream_ids.is_some() as u8
            + self.creator.is_some() as u8
            + self.recipient.is_some() as u8)
            == 1
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct QueryStreamMsg {
    /// The ID of the stream to query
    pub stream_id: Uint64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct QueryClaimableFundsMsg {
    /// The list of IDs of streams to query.
    pub streams: Vec<Uint64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query Owner of token message
pub struct QueryOwnerOfMsg {
    pub token_id: String,
    pub include_expired: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query approval status message
pub struct QueryApprovalMsg {
    pub token_id: String,
    pub spender: String,
    pub include_expired: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query all approvals message
pub struct QueryApprovalsMsg {
    pub token_id: String,
    pub include_expired: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query operators message
pub struct QueryAllOperatorsMsg {
    pub owner: String,
    pub include_expired: Option<bool>,
    pub start_after: Option<String>,
    pub limit: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query number of tokens message
pub struct QueryNumTokensMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query contract info message
pub struct QueryContractInfoMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query nft info message
pub struct QueryNftInfoMsg {
    pub token_id: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query all nft info message
pub struct QueryAllNftInfoMsg {
    pub token_id: String,
    pub include_expired: Option<bool>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query tokens message
pub struct QueryTokensMsg {
    pub owner: String,
    pub start_after: Option<String>,
    pub limit: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
/// cw721 Query all tokens message
pub struct QueryAllTokensMsg {
    pub start_after: Option<String>,
    pub limit: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    Streams(QueryStreamsMsg),
    Stream(QueryStreamMsg),
    ClaimableFunds(QueryClaimableFundsMsg),

    OwnerOf(QueryOwnerOfMsg),
    Approval(QueryApprovalMsg),
    Approvals(QueryApprovalsMsg),
    AllOperators(QueryAllOperatorsMsg),
    NumTokens(QueryNumTokensMsg),
    ContractInfo(QueryContractInfoMsg),
    NftInfo(QueryNftInfoMsg),
    AllNftInfo(QueryAllNftInfoMsg),
    Tokens(QueryTokensMsg),
    AllTokens(QueryAllTokensMsg),
}

impl From<QueryMsg> for CW721QueryMsg {
    fn from(msg: QueryMsg) -> CW721QueryMsg {
        match msg {
            QueryMsg::OwnerOf(msg) => CW721QueryMsg::OwnerOf {
                token_id: msg.token_id,
                include_expired: msg.include_expired,
            },
            QueryMsg::Approval(msg) => CW721QueryMsg::Approval {
                token_id: msg.token_id,
                spender: msg.spender,
                include_expired: msg.include_expired,
            },
            QueryMsg::Approvals(msg) => CW721QueryMsg::Approvals {
                token_id: msg.token_id,
                include_expired: msg.include_expired,
            },
            QueryMsg::AllOperators(msg) => CW721QueryMsg::AllOperators {
                owner: msg.owner,
                include_expired: msg.include_expired,
                start_after: msg.start_after,
                limit: msg.limit,
            },
            QueryMsg::NumTokens(_) => CW721QueryMsg::NumTokens {},
            QueryMsg::ContractInfo(_) => CW721QueryMsg::ContractInfo {},
            QueryMsg::NftInfo(msg) => CW721QueryMsg::NftInfo {
                token_id: msg.token_id,
            },
            QueryMsg::AllNftInfo(msg) => CW721QueryMsg::AllNftInfo {
                token_id: msg.token_id,
                include_expired: msg.include_expired,
            },
            QueryMsg::Tokens(msg) => CW721QueryMsg::Tokens {
                owner: msg.owner,
                start_after: msg.start_after,
                limit: msg.limit,
            },
            QueryMsg::AllTokens(msg) => CW721QueryMsg::AllTokens {
                start_after: msg.start_after,
                limit: msg.limit,
            },
            _ => panic!("cannot covert {:?} to CW721QueryMsg", msg),
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ConfigResponse {
    pub config: Config,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct StreamsResponse {
    pub streams: Vec<StreamInfo>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct StreamResponse {
    pub stream: StreamInfo,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimableFundsPair {
    pub id: String,
    pub amount: Uint128,
}
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimableFundsResponse {
    /// List of claimable funds by Stream ID and amount claimable
    pub claimable_amounts: Vec<ClaimableFundsPair>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_serialization() {
        let execute = ExecuteMsg::ClaimFunds(ClaimFundsMsg {
            stream_ids: vec![Uint64::zero()],
        });
        let json = serde_json::to_string(&execute).unwrap();
        let expected = r#"{"claim_funds":{"token_ids":["PAY-0"]}}"#;
        assert_eq!(json, expected);
    }
}
```
---

### FundStreamMsg

    Use this message to increase the total funds of an active Stream. Only active mutable streams can be funded. 

```rust minter.rs

pub struct FundStreamMsg {
    pub stream_id: Uint64,
}
```
---
### ClaimFundsMsg

    Use this message to increase the total funds of an active Stream. Only active mutable streams can be funded. 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimFundsMsg {
    /// A list of IDs of streams that will be claimed from
    pub stream_ids: Vec<Uint64>,
}

```
---

### ClaimAllFundsMsg

Claims all the streams that the sender of this message receives from.

```rust minter.rs focus=3
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ClaimAllFundsMsg {}
```

---

### ChangeStreamInfoMsg

Change the name of a mutable stream. 


_`pub stream_id:`_ The ID of the stream to change.  
_`pub name:`_ If specified, the new name of the stream.  

```rust minter.rs focus=3:5
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ChangeStreamInfoMsg {
    pub stream_id: Uint64,
    pub name: Option<String>,
}
```
---

### CancelStreamMsg

Cancels a stream. Unpaid funds get sent to the `recipient_addr`. 


_`pub stream_id:`_ The ID of the stream to change.  
_`pub recipient_addr:`_ If specified, the address that receives the cancellation's refund  

```rust minter.rs focus=3:5
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct CancelStreamMsg {
    pub stream_id: Uint64,
    pub recipient_addr: Option<String>,
}
```

---

### TransferNftMsg

Transfer a stream's cw721 NFT to a `recipient`. 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct TransferNftMsg {
    pub recipient: String,
    pub token_id: String,
}
```

---

### SendNftMsg

Send a stream's cw721 NFT to an address controlled by a smart contract. For more info, check out [the cw721 docs](https://github.com/CosmWasm/cw-nfts/blob/main/packages/cw721/README.md#messages). 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct SendNftMsg {
    pub contract: String,
    pub token_id: String,
    pub msg: Binary,
}
```

---

### ApproveMsg

Grants the `spender` permission to send or transfer a stream's cw721. For more info, check out [the cw721 docs](https://github.com/CosmWasm/cw-nfts/blob/main/packages/cw721/README.md#messages). 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ApproveMsg {
    pub spender: String,
    pub token_id: String,
    pub expires: Option<Expiration>,
}
```

---

### RevokeMsg

Revokes previously given permission of the `spender` to send or transfer a stream's cw721. For more info, check out [the cw721 docs](https://github.com/CosmWasm/cw-nfts/blob/main/packages/cw721/README.md#messages). 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct RevokeMsg {
    pub spender: String,
    pub token_id: String,
}
```

---

### ApproveAllMsg

Approve all token messages. For more info, check out [the cw721 docs](https://github.com/CosmWasm/cw-nfts/blob/main/packages/cw721/README.md#messages). 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct ApproveAllMsg {
    pub operator: String,
    pub expires: Option<Expiration>,
}
```

---

### RevokeAllMsg

Revokes all cw721 approval messages. For more info, check out [the cw721 docs](https://github.com/CosmWasm/cw-nfts/blob/main/packages/cw721/README.md#messages). 

```rust minter.rs focus=3:6
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct RevokeAllMsg {
    pub operator: String,
}
```


</CH.Scrollycoding>

