---
sidebar_position: 3
---

# Smart Contract

## Functions

<CH.Scrollycoding>

### create_stream()

Create a new stream with the given parameters in the [`CreateStreamMsg`] struct.

The stream's ID is a unique incrementing number and is returned in the `token_id` attribute.

When creating a stream, you can choose whether it will be `immutable`. Immutable streams cannot be altered once created. 

``` rust contract.rs 
pub fn create_stream(
    deps: DepsMut,
    info: MessageInfo,
    env: Env,
    data: CreateStreamMsg,
    cw20_info: Option<Cw20ReceiveMsg>,
) -> Result<Response, ContractError> {
    let state = STATE.load(deps.storage)?;

    let cw721_contract = cw721_base::Cw721Contract::<Extension, Empty>::default();

    if data.issuance_start_timestamp >= data.issuance_end_timestamp {
        return Err(ContractError::TimeError {});
    }

    let current_mint_id = state.current_mint_id;

    let expected_token = match data.asset_info {
        AssetInfoBase::Cw20(ref cw20_addr) => cw20_addr.to_string(),
        AssetInfoBase::Native(ref denom) => denom.to_string(),
    };

    let mut initial_funds = Uint128::zero();
    let creator;
    //Check if we received the correct token or native currency
    if let Some(cw20_info) = cw20_info {
        let sent_token_addr = info.sender.to_string();
        if sent_token_addr != expected_token {
            return Err(ContractError::SentTokenMismatch {
                received: sent_token_addr,
                expected: expected_token,
            });
        }
        initial_funds = cw20_info.amount;
        creator = cw20_info.sender;
    } else {
        for coin in info.funds.clone() {
            if coin.denom != expected_token {
                return Err(ContractError::SentTokenMismatch {
                    received: coin.denom,
                    expected: expected_token,
                });
            }
            initial_funds += coin.amount;
        }
        creator = info.sender.to_string();
    }

    let token_id = stream_to_nft_id(&current_mint_id);
    let stream_info = StreamInfo {
        status: StreamStatus::Valid,
        immutable: data.immutable,
        nft_token_id: token_id.clone(),
        token_id: current_mint_id,
        name: data.name.clone(),
        asset_info: data.asset_info.clone(),
        creator_addr: deps.api.addr_validate(&creator)?,
        issuance_start_timestamp: data.issuance_start_timestamp,
        issuance_end_timestamp: data.issuance_end_timestamp,
        last_claimed_timestamp: data.issuance_start_timestamp,
        total_funded: initial_funds,
        funds_remaining: initial_funds,
    };
    STREAMS().save(deps.storage, current_mint_id.u64(), &stream_info)?;

    STATE.save(
        deps.storage,
        &State {
            current_mint_id: current_mint_id + Uint64::from(1u64),
        },
    )?;

    let mint_msg = MintMsg {
        token_id: token_id.clone(),
        owner: data.recipient_addr.to_string(),
        token_uri: None,
        extension: None,
    };
    let nft_msg_info = MessageInfo {
        sender: env.contract.address.clone(),
        funds: info.funds,
    };
    let mint_res = cw721_contract.mint(deps, env, nft_msg_info, mint_msg)?;

    Ok(Response::new()
        .add_attributes(vec![
            attr("action", "create_stream"),
            attr("name", data.name),
            attr(
                "asset",
                match data.asset_info {
                    AssetInfo::Cw20(address) => address.to_string(),
                    AssetInfo::Native(denom) => denom,
                },
            ),
            attr("token_id", token_id),
            attr("payer_addr", creator),
            attr("payee_addr", data.recipient_addr),
            attr("initial_balance", stream_info.funds_remaining.to_string()),
            attr(
                "start_timestamp",
                stream_info.issuance_start_timestamp.to_string(),
            ),
            attr(
                "end_timestamp",
                stream_info.issuance_end_timestamp.to_string(),
            ),
        ])
        .add_attributes(mint_res.attributes))
}

```

---

### fund_stream()

Fund a stream with the given amount of tokens. Parameters are in the [`FundStreamMsg`] struct.
Note that the stream is unchanged EXCEPT for the total amount of tokens that will be transferred.
This means that the stream will simply increase the rate at which funds are transferredl, since
The time over which the funds are transferred is kept constant.

``` rust contract.rs 
pub fn fund_stream(
    deps: DepsMut,
    info: MessageInfo,
    env: Env,
    data: FundStreamMsg,
    cw20_info: Option<Cw20ReceiveMsg>,
) -> Result<Response, ContractError> {
    let cw721_contract = cw721_base::Cw721Contract::<Extension, Empty>::default();
    let streams = STREAMS();
    let mut stream_info = streams.load(deps.storage, data.stream_id.u64())?;
    let expected_token = match stream_info.asset_info {
        AssetInfoBase::Cw20(ref cw20_addr) => cw20_addr.to_string(),
        AssetInfoBase::Native(ref denom) => denom.to_string(),
    };

    if stream_info.status == StreamStatus::Cancelled {
        return Err(ContractError::StreamCancelled {});
    }

    if stream_info.immutable {
        return Err(ContractError::Immutable {});
    }

    if Uint64::from(env.block.time.seconds()) > stream_info.issuance_end_timestamp {
        return Err(ContractError::StreamExpired {});
    }

    let mut added_funds = Uint128::zero();
    //Check if we received the correct token or native currency
    if let Some(cw20_info) = cw20_info {
        let sent_token_addr = info.sender.to_string();
        if sent_token_addr != expected_token {
            return Err(ContractError::SentTokenMismatch {
                received: sent_token_addr,
                expected: expected_token,
            });
        }
        added_funds = cw20_info.amount;
    } else {
        for coin in info.funds {
            if coin.denom != expected_token {
                return Err(ContractError::SentTokenMismatch {
                    received: coin.denom,
                    expected: expected_token,
                });
            }
            added_funds += coin.amount;
        }
    }

    stream_info.funds_remaining += added_funds;
    stream_info.total_funded += added_funds;
    streams.save(deps.storage, data.stream_id.u64(), &stream_info)?;
    Ok(Response::new().add_attributes(vec![
        attr("action", "fund_stream"),
        attr("name", stream_info.name),
        attr("token_id", data.stream_id),
        attr(
            "asset",
            match stream_info.asset_info {
                AssetInfo::Cw20(address) => address.to_string(),
                AssetInfo::Native(denom) => denom,
            },
        ),
        attr("payer_addr", stream_info.creator_addr.to_string()),
        attr(
            "payee_addr",
            cw721_contract
                .owner_of(deps.as_ref(), env, stream_info.nft_token_id, true)?
                .owner,
        ),
        attr("added_balance", added_funds.to_string()),
        attr("updated_balance", stream_info.funds_remaining),
    ]))
}
```

---

### claim_funds()

Claim funds from a stream. Parameters are in the [`ClaimFundsMsg`] struct.
You may specify multiple streams to claim from, but the sender must be the owner of any stream that is claimed.

``` rust contract.rs
pub fn claim_funds(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    data: ClaimFundsMsg,
) -> Result<Response, ContractError> {
    let cw721_contract = cw721_base::Cw721Contract::<Extension, Empty>::default();
    let mut claim_messages = vec![];

    let mut token_ids = vec![];
    let mut claimed_amounts = vec![];
    let mut remaining_balances = vec![];

    let streams = STREAMS();
    for id in data.stream_ids {
        let mut stream = streams.load(deps.storage, id.u64())?;
        let stream_owner = cw721_contract
            .owner_of(
                deps.as_ref(),
                env.clone(),
                stream.nft_token_id.clone(),
                true,
            )?
            .owner;
        if stream_owner != info.sender {
            return Err(ContractError::Unauthorized {});
        }

        let claimable_amount = get_claimable_amount(env.clone(), &stream)?;

        if claimable_amount.is_zero() {
            continue;
        }

        stream.funds_remaining -= claimable_amount;
        stream.last_claimed_timestamp = Uint64::from(env.block.time.seconds());

        streams.save(deps.storage, id.u64(), &stream)?;

        claim_messages.push(match stream.asset_info.clone() {
            AssetInfoBase::Cw20(address) => {
                CosmosMsg::Wasm(WasmMsg::Execute {
                    contract_addr: String::from(address),
                    msg: to_binary(&Cw20ExecuteMsg::Transfer {
                        recipient: stream_owner,
                        amount: claimable_amount, //todo: discuss and check for amount edge cases
                    })?,
                    funds: vec![],
                })
            }
            AssetInfoBase::Native(denom) => {
                CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {
                    to_address: stream_owner,
                    amount: vec![Coin {
                        denom,
                        amount: claimable_amount, //todo: discuss and check for amount edge cases
                    }],
                })
            }
        });

        token_ids.push(id.to_string());
        claimed_amounts.push(claimable_amount.to_string());
        remaining_balances.push(stream.funds_remaining.to_string());
    }

    Ok(Response::new()
        .add_messages(claim_messages)
        .add_attribute("action", "claim_funds")
        .add_attribute("payee_addr", info.sender.to_string())
        .add_attributes(vec![
            attr("token_ids", token_ids.join(",")),
            attr("claimed_amounts", claimed_amounts.join(",")),
            attr("remaining_balances", remaining_balances.join(",")),
        ]))
}
```
---

### claim_funds()

Claim funds from a stream. Parameters are in the [`ClaimFundsMsg`] struct.
You may specify multiple streams to claim from, but the sender must be the owner of any stream that is claimed.

```rust contract.rs

pub fn claim_funds(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    data: ClaimFundsMsg,
) -> Result<Response, ContractError> {
    let cw721_contract = cw721_base::Cw721Contract::<Extension, Empty>::default();
    let mut claim_messages = vec![];

    let mut token_ids = vec![];
    let mut claimed_amounts = vec![];
    let mut remaining_balances = vec![];

    let streams = STREAMS();
    for id in data.stream_ids {
        let mut stream = streams.load(deps.storage, id.u64())?;
        let stream_owner = cw721_contract
            .owner_of(
                deps.as_ref(),
                env.clone(),
                stream.nft_token_id.clone(),
                true,
            )?
            .owner;
        if stream_owner != info.sender {
            return Err(ContractError::Unauthorized {});
        }

        let claimable_amount = get_claimable_amount(env.clone(), &stream)?;

        if claimable_amount.is_zero() {
            continue;
        }

        stream.funds_remaining -= claimable_amount;
        stream.last_claimed_timestamp = Uint64::from(env.block.time.seconds());

        streams.save(deps.storage, id.u64(), &stream)?;

        claim_messages.push(match stream.asset_info.clone() {
            AssetInfoBase::Cw20(address) => {
                CosmosMsg::Wasm(WasmMsg::Execute {
                    contract_addr: String::from(address),
                    msg: to_binary(&Cw20ExecuteMsg::Transfer {
                        recipient: stream_owner,
                        amount: claimable_amount, //todo: discuss and check for amount edge cases
                    })?,
                    funds: vec![],
                })
            }
            AssetInfoBase::Native(denom) => {
                CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {
                    to_address: stream_owner,
                    amount: vec![Coin {
                        denom,
                        amount: claimable_amount, //todo: discuss and check for amount edge cases
                    }],
                })
            }
        });

        token_ids.push(id.to_string());
        claimed_amounts.push(claimable_amount.to_string());
        remaining_balances.push(stream.funds_remaining.to_string());
    }

    Ok(Response::new()
        .add_messages(claim_messages)
        .add_attribute("action", "claim_funds")
        .add_attribute("payee_addr", info.sender.to_string())
        .add_attributes(vec![
            attr("token_ids", token_ids.join(",")),
            attr("claimed_amounts", claimed_amounts.join(",")),
            attr("remaining_balances", remaining_balances.join(",")),
        ]))
}
```

---

### claim_all_funds()

Claims all the streams that the sender receives from. No parameters.
Proxies a call to [`claim_funds`] with all the streams that the sender owns.

```rust contract.rs
pub fn claim_all_funds(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
) -> Result<Response, ContractError> {
    let streams = query_recipient_streams(deps.as_ref(), info.sender.clone(), None, None)?.streams;

    claim_funds(
        deps,
        env,
        info,
        ClaimFundsMsg {
            stream_ids: streams.iter().map(|s| s.token_id).collect(),
        },
    )
}

```
---

### change_stream_info()

Change attributes of mutable streams. Parameters are in the [`ChangeStreamInfoMsg`] struct.

```rust contract.rs
pub fn change_stream_info(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    data: ChangeStreamInfoMsg,
) -> Result<Response, ContractError> {
    let streams = STREAMS();
    let mut stream = streams.load(deps.storage, data.stream_id.u64())?;

    if info.sender != stream.creator_addr {
        return Err(ContractError::Unauthorized {});
    }

    if stream.immutable {
        return Err(ContractError::Immutable {});
    }

    stream.name = data.name.unwrap_or(stream.name);

    streams.save(deps.storage, data.stream_id.u64(), &stream)?;

    Ok(Response::new()
        .add_attribute("action", "change_stream_info")
        .add_attribute("token_id", data.stream_id)
        .add_attribute("name", stream.name))
}
```

---

### cancel_stream()

Cancel a stream. Parameters are in the [`CancelStreamMsg`] struct.
Can only be cancelled by the creator of the stream.
If the stream is immutable, it cannot be cancelled.
Upon cancellation, the claimable funds are held for the recipient to claim, and the remaining funds are returned to the address specified in the message.

```rust contract.rs
pub fn cancel_stream(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    data: CancelStreamMsg,
) -> Result<Response, ContractError> {
    let streams = STREAMS();
    let mut stream = streams.load(deps.storage, data.stream_id.u64())?;
    if stream.creator_addr != info.sender {
        return Err(ContractError::Unauthorized {});
    }

    if stream.immutable {
        return Err(ContractError::Immutable {});
    }
    let cw721_contract = cw721_base::Cw721Contract::<Extension, Empty>::default();
    let payee = cw721_contract
        .owner_of(
            deps.as_ref(),
            env.clone(),
            stream.nft_token_id.clone(),
            true,
        )?
        .owner;

    let refund_addr = data
        .recipient_addr
        .unwrap_or_else(|| stream.creator_addr.to_string());

    let claimable_amount = get_claimable_amount(env, &stream)?;
    let return_amount = stream.funds_remaining - claimable_amount;
    stream.total_funded -= return_amount;
    stream.funds_remaining = claimable_amount;
    stream.status = StreamStatus::Cancelled;

    streams.save(deps.storage, data.stream_id.u64(), &stream)?;

    let return_message = match stream.asset_info {
        AssetInfoBase::Cw20(address) => CosmosMsg::Wasm(WasmMsg::Execute {
            contract_addr: String::from(address),
            msg: to_binary(&Cw20ExecuteMsg::Transfer {
                recipient: refund_addr.to_string(),
                amount: return_amount,
            })?,
            funds: vec![],
        }),
        AssetInfoBase::Native(denom) => CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {
            to_address: refund_addr.to_string(),
            amount: vec![Coin {
                denom,
                amount: return_amount,
            }],
        }),
    };

    Ok(Response::new()
        .add_message(return_message)
        .add_attribute("action", "cancel_stream")
        .add_attribute("token_id", data.stream_id)
        .add_attribute("payer_addr", stream.creator_addr)
        .add_attribute("payee_addr", payee)
        .add_attribute("refund_addr", refund_addr)
        .add_attribute("returned_balance", return_amount)
        .add_attribute("claimable_amount", claimable_amount))
}
```

---

### query_config()

Returns this contract's configuration. See [`Config`].

``` rust contract.rs

pub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {
    let config = CONFIG.load(deps.storage)?;
    Ok(ConfigResponse { config })
}
```

---

### nft_to_stream_id()

Converts an ID in the format `PAY-XXX...X` to a `Uint64`.

```rust contract.rs
pub fn nft_to_stream_id(nft_token_id: &str) -> Uint64 {
    Uint64::try_from(nft_token_id.rsplit_once('-').unwrap().1).unwrap()
}
```

---

### stream_to_nft_id()

Converts an ID in `Uint64` form to the format `PAY-XXX...X`.

```rust contract.rs
pub fn stream_to_nft_id(stream_id: &Uint64) -> String {
    format!("PAY-{:0>20}", stream_id.u64())
}
```

</CH.Scrollycoding>
